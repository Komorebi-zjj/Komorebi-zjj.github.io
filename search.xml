<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>经典排序算法总结</title>
    <url>/2020/05/25/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>之前看了一些排序算法的内容，但一直没有一个系统的总结，了解的也都是零零散散的知识点。现在将菜鸟教程上的排序算法的知识点做一个梳理。<br><a id="more"></a></p>
</blockquote>
<p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的排序算法可用一个表格概括：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">排序方式</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">In-place</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">In-place</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">In-place</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">$O(n{\log}n)$</td>
<td style="text-align:center">$O(n{\log}^{2}n)$</td>
<td style="text-align:center">$O(n{\log}^{2}n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">In-place</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">$O(n{\log}n)$</td>
<td style="text-align:center">$O(n{\log}n)$</td>
<td style="text-align:center">$O(n{\log}n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">Out-place</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$O(n{\log}n)$</td>
<td style="text-align:center">$O(n{\log}n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O({\log}n)$</td>
<td style="text-align:center">In-place</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$O(n{\log}n)$</td>
<td style="text-align:center">$O(n{\log}n)$</td>
<td style="text-align:center">$O(n{\log}n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">In-place</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">计数排序</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(k)$</td>
<td style="text-align:center">Out-place</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">桶排序</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">Out-place</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">基数排序</td>
<td style="text-align:center">$O(n\times k)$</td>
<td style="text-align:center">$O(n\times k)$</td>
<td style="text-align:center">$O(n\times k)$</td>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">Out-place</td>
<td style="text-align:center">稳定</td>
</tr>
</tbody>
</table>
</div>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2020/05/25/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/冒泡排序.gif" alt="冒泡排序"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, temp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                                temp = arr[j];</span><br><span class="line">                                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">        bubble_sort(arr, len);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是$O(n^2)$ 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h2 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h2><ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ol>
<h2 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2020/05/25/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/选择排序.gif" alt="选择排序"></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span> <span class="comment">//交换两个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">                <span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">                <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)     <span class="comment">//走访未排序的元素</span></span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &lt; arr[<span class="built_in">min</span>])    <span class="comment">//找到目前最小值</span></span><br><span class="line">                                <span class="built_in">min</span> = j;    <span class="comment">//记录最小值</span></span><br><span class="line">                swap(&amp;arr[<span class="built_in">min</span>], &amp;arr[i]);    <span class="comment">//做交换</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p>
<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol>
<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
</ol>
<h2 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2020/05/25/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/插入排序.gif" alt="插入排序"></p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,key;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">                key = arr[i];</span><br><span class="line">                j=i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>((j&gt;=<span class="number">0</span>) &amp;&amp; (arr[j]&gt;key)) &#123;</span><br><span class="line">                        arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                        j--;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+<span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<h2 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h2><ol>
<li>选择一个增量序列 $t_1，t_2，……，t_k$,其中$t_i &gt; t_j, t_k = 1$；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<h2 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2020/05/25/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/希尔排序.gif" alt="希尔排序"></p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> gap, i, j;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (gap = len &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">                        temp = arr[i];</span><br><span class="line">                        <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                                arr[j + gap] = arr[j];</span><br><span class="line">                        arr[j + gap] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> reg[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= <span class="built_in">end</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">end</span> - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">    <span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line">    <span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = <span class="built_in">end</span>;</span><br><span class="line">    merge_sort_recursive(arr, reg, start1, end1);</span><br><span class="line">    merge_sort_recursive(arr, reg, start2, end2);</span><br><span class="line">    <span class="keyword">int</span> k = start;</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">        reg[k++] = arr[start1++];</span><br><span class="line">    <span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start2++];</span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= <span class="built_in">end</span>; k++)</span><br><span class="line">        arr[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reg[len];</span><br><span class="line">    merge_sort_recursive(arr, reg, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：、</p>
<ul>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li>
</ul>
<h2 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h2><ol>
<li>将初始待排序关键字序列$(R_1,R_2,…,R_n)$构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素$R[1]$与最后一个元素$R[n]$交换，此时得到新的无序区$(R_1,R_2,…,R_n-1)$和新的有序区$R_n$，且满足$R[1,2,,…,n-1]&lt;=R[n]$;</li>
<li>由于交换后新的堆顶$R[1]$可能违反堆的性质，因此需要对当前的无序区$(R_1,R_2,…,R_n-1)$调整为新堆，然后再次将$R[1]$与无序区最后一个元素交换，得到新的无序区$(R_1,R_2,…,R_n-2)$和新的有序区$(R_n-1,R_n)$。不断重复此过程直到有序区的元素个数为$n-1$,则整个排序过程结束。</li>
</ol>
<h2 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2020/05/25/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/堆排序.gif" alt="堆排序"></p>
<h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立父节点指标和子节点指标</span></span><br><span class="line">    <span class="keyword">int</span> dad = start;</span><br><span class="line">    <span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= <span class="built_in">end</span>) &#123; <span class="comment">// 若子节点指标在范围內才做比较</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= <span class="built_in">end</span> &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">// 先比较两个子节点大小，选择最大的</span></span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">//如果父节点大于子节点代表调整完毕，直接跳出函数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 否则交换父子內容再继续子节点和孙节点比较</span></span><br><span class="line">            swap(&amp;arr[dad], &amp;arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 初始化，ii从最后一父节点开始调整</span></span><br><span class="line">    <span class="keyword">for</span> (i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        max_heapify(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 先將第一個元素和已排好元素前一位做交换，再重新调整，直到排序完毕</span></span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>], &amp;arr[i]);</span><br><span class="line">        max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    heap_sort(arr, len);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><ol>
<li>找出待排序的数组中最大和最小二点元素；</li>
<li>统计数组中每个值为$i$的元素出现的次数，存入数组$C$的第$i$项；</li>
<li>对所有的计数累加（从$C$中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组，将每个元素$i$放在新数组的第$C(i)$项，每放一个元素就将$C(i)$减去$1$；</li>
</ol>
<h2 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2020/05/25/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/计数排序.gif" alt="计数排序"></p>
<h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>, arr[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">counting_sort</span><span class="params">(<span class="keyword">int</span> *ini_arr, <span class="keyword">int</span> *sorted_arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *count_arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                count_arr[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                count_arr[ini_arr[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                count_arr[k] += count_arr[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (j = n; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">                sorted_arr[--count_arr[ini_arr[j - <span class="number">1</span>]]] = ini_arr[j - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">free</span>(count_arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        <span class="keyword">int</span> *sorted_arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        srand(time(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                arr[i] = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ini_array: "</span>);</span><br><span class="line">        print_arr(arr, n);</span><br><span class="line">        counting_sort(arr, sorted_arr, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sorted_array: "</span>);</span><br><span class="line">        print_arr(sorted_arr, n);</span><br><span class="line">        <span class="built_in">free</span>(arr);</span><br><span class="line">        <span class="built_in">free</span>(sorted_arr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p> 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ul>
<li>在额外空间充足的情况下，尽量增大桶的数量；</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ul>
<h2 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h2><ol>
<li>设置一个定量的空桶作为空桶子；</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子去；</li>
<li>对每个不是空的桶子进行排序；</li>
<li>从不是空的桶子里把项目再放回到原来的序列中。</li>
</ol>
<h2 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2020/05/25/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/桶排序.gif" alt="桶排序"></p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUCKET_NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">        explicit ListNode(int i=0):mData(i),mNext(NULL)&#123;&#125;</span><br><span class="line">        ListNode* mNext;</span><br><span class="line">        <span class="keyword">int</span> mData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">insert</span><span class="params">(ListNode* head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        ListNode dummyNode;</span><br><span class="line">        ListNode *newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        ListNode *pre,*curr;</span><br><span class="line">        dummyNode.mNext = head;</span><br><span class="line">        pre = &amp;dummyNode;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">NULL</span>!=curr &amp;&amp; curr-&gt;mData&lt;=val)&#123;</span><br><span class="line">                pre = curr;</span><br><span class="line">                curr = curr-&gt;mNext;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;mNext = curr;</span><br><span class="line">        pre-&gt;mNext = newNode;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode *head1,ListNode *head2)</span></span>&#123;</span><br><span class="line">        ListNode dummyNode;</span><br><span class="line">        ListNode *dummy = &amp;dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">NULL</span>!=head1 &amp;&amp; <span class="literal">NULL</span>!=head2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(head1-&gt;mData &lt;= head2-&gt;mData)&#123;</span><br><span class="line">                        dummy-&gt;mNext = head1;</span><br><span class="line">                        head1 = head1-&gt;mNext;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dummy-&gt;mNext = head2;</span><br><span class="line">                        head2 = head2-&gt;mNext;</span><br><span class="line">                &#125;</span><br><span class="line">                dummy = dummy-&gt;mNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>!=head1) dummy-&gt;mNext = head1;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span>!=head2) dummy-&gt;mNext = head2;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; buckets(BUCKET_NUM,(ListNode*)(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> index = arr[i]/BUCKET_NUM;</span><br><span class="line">                ListNode *head = buckets.at(index);</span><br><span class="line">                buckets.at(index) = insert(head,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *head = buckets.at(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;BUCKET_NUM;++i)&#123;</span><br><span class="line">                head = Merge(head,buckets.at(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                arr[i] = head-&gt;mData;</span><br><span class="line">                head = head-&gt;mNext;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<h2 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h2><ol>
<li>取得数组中的最大数，并取得位数；</li>
<li><code>arr</code>为原始数组，从最低位开始取每个位组成<code>radix</code>数组；</li>
<li>对<code>radix</code>进行计数排序（利用计数排序适用于小范围数的特点）</li>
</ol>
<h2 id="动态演示"><a href="#动态演示" class="headerlink" title="动态演示"></a>动态演示</h2><p><img src="/2020/05/25/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/基数排序.gif" alt="基数排序"></p>
<h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 20</span></span><br><span class="line"><span class="comment">//#define SHOWPASS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, b[MAX], m = a[<span class="number">0</span>], <span class="built_in">exp</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; m) &#123;</span><br><span class="line">      m = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (m / <span class="built_in">exp</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> bucket[BASE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      bucket[(a[i] / <span class="built_in">exp</span>) % BASE]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">      bucket[i] += bucket[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      b[--bucket[(a[i] / <span class="built_in">exp</span>) % BASE]] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      a[i] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exp</span> *= BASE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOWPASS</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nPASS   : "</span>);</span><br><span class="line">    <span class="built_in">print</span>(a, n);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> arr[MAX];</span><br><span class="line">  <span class="keyword">int</span> i, n;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter total elements (n &lt;= %d) : "</span>, MAX);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  n = n &lt; MAX ? n : MAX;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter %d Elements : "</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\nARRAY  : "</span>);</span><br><span class="line">  <span class="built_in">print</span>(&amp;arr[<span class="number">0</span>], n);</span><br><span class="line"></span><br><span class="line">  radixsort(&amp;arr[<span class="number">0</span>], n);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\nSORTED : "</span>);</span><br><span class="line">  <span class="built_in">print</span>(&amp;arr[<span class="number">0</span>], n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>层次分析模型</title>
    <url>/2020/05/19/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>层次分析模型</strong>(AHP)是将要决策的问题及其有关因素分解成目标、准则、方案等层次，进而进行定性和定量的决策方法。<br><a id="more"></a></p>
<h1 id="模型概述"><a href="#模型概述" class="headerlink" title="模型概述"></a>模型概述</h1><p>AHP的特征是合理的将定性和定量决策结合起来，按照思维、心理的规律把决策过程细致化、数量化、层次化。<br>运用层次分析方法建模，大体何以分为四个步骤进行：</p>
<ul>
<li>建立层次结构模型</li>
<li>构造各层次的判断矩阵</li>
<li>计算权重</li>
<li>一致性检验</li>
</ul>
<h1 id="层次结构模型的建立"><a href="#层次结构模型的建立" class="headerlink" title="层次结构模型的建立"></a>层次结构模型的建立</h1><p>分层：</p>
<ol>
<li>最高层：这一层只有一个元素，一般是分析问题的预定目标和理想结果。</li>
<li>中间层：这一层次中包含了为了实现目标所涉及的中间环节，主要是一些考虑指标和一些准则。</li>
<li>最底层：这一层次中包含了为了实现目标可供选择的各种方案。</li>
</ol>
<p>以流行病界定因素为例构建层次结构图：</p>
<p><img src="/2020/05/19/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B/层次分析模型.jpg" alt="层次分析模型"></p>
<h1 id="构造判断矩阵"><a href="#构造判断矩阵" class="headerlink" title="构造判断矩阵"></a>构造判断矩阵</h1><p>对于各层次各影响因素的权重确定，将各因素进行两两比较，对比时减少相对尺度，以减少性质不同因素相互比较的困难，提高准确度。通过由专家对同一层次内的各个因素的相对重要性进行打分。相对重要性的比例标度1~9取之间。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">标度</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">表示两个因素相比，具有相同重要性</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">表示两个因素相比，前者比后者稍微重要</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">表示两个因素相比，前者比后者明显重要</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">表示两个因素相比，前者比后者强烈重要</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">表示两个因素相比，前者比后者极端重要</td>
</tr>
<tr>
<td style="text-align:center">2，4，6，8</td>
<td style="text-align:center">表示上述相邻判断的中间值</td>
</tr>
<tr>
<td style="text-align:center">倒数</td>
<td style="text-align:center">因素$i$与$j$的相对重要性是因素 $ j $ 与因素 $ i $ 重要性之比的倒数</td>
</tr>
</tbody>
</table>
</div>
<p>随后对各个元素构造判断矩阵$A$(正交矩阵)，用$a_{ij}$表示第$i$个因素相对于第$j$个因素的比较结果：</p>
<script type="math/tex; mode=display">A=({a}_{ij})_{n\times n}=\left[ \begin{matrix}
   {a}_{11} & {a}_{12} & ... & {a}_{1n}  \\
   {a}_{21} & {a}_{22} & ... & {a}_{2n}  \\
   ... & ... & ... & ...  \\
   {a}_{n1} & {a}_{n2} & ... & {a}_{nn}  \\
\end{matrix} \right]</script><h1 id="计算权重"><a href="#计算权重" class="headerlink" title="计算权重"></a>计算权重</h1><p>将矩阵$A$的各行向量进行几何平均，然后进行归一化，即得到各影响因素的权重和特征向量$W$ ：</p>
<script type="math/tex; mode=display">{W}_{i}=\frac{\overline{W}}{\sum\limits_{i=1}^{n}\overline{W}_{i}}
,
W=\left\{ \begin{matrix}
   {W}_{1}  \\
   {W}_{2}  \\
   .  \\
   .  \\
   {W}_{n}  \\
\end{matrix} \right\}</script><h1 id="一致性检验"><a href="#一致性检验" class="headerlink" title="一致性检验"></a>一致性检验</h1><p>为了确保判断数值前后的一致性，也为了避免数据矛盾造成特征根发生变化，对计算的结果及决策的精确性造成影响，在得到比较矩阵后，需要对矩阵中的数据进行一致性检验。在检验时，使用一致性指标$CI$、随机一致性指标$RI$和一致性比例$CR$来比较判断矩阵中的最大特征根$\lambda_{\max}$ 及对应的特征向量是否前后保持一致，进而得出检验结果。</p>
<p>计算最大特征根$\lambda_{\max}$：</p>
<script type="math/tex; mode=display">\lambda_{\max }=\frac{1}{n}\sum\limits_{i=1}^n\frac{(AW)_i}{W_i}</script><p>一致性比例$CR$:</p>
<script type="math/tex; mode=display">CR=\frac{CI}{RI}</script><p>当$CR<0.1$时，则通过一致性检验，如果$CR>0.1$，则一致性检验不通过，需要重新构建判断矩阵。</0.1$时，则通过一致性检验，如果$CR></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>以与大流行病相关的感染数量，病死人数，疫情持续时间等因素进行层次分析为例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">大流行病的相关因素</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">感染数量</td>
<td style="text-align:center">病死人数</td>
<td style="text-align:center">疫情持续时间</td>
</tr>
<tr>
<td style="text-align:center">感染数量</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1/3</td>
</tr>
<tr>
<td style="text-align:center">病死人数</td>
<td style="text-align:center">1/2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1/5</td>
</tr>
<tr>
<td style="text-align:center">疫情持续时间</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>通过<code>MATLAB</code>编程代码如下：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc</span><br><span class="line">clear all</span><br><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">1</span>/<span class="number">3</span>;<span class="number">1</span>/<span class="number">2</span> <span class="number">1</span> <span class="number">1</span>/<span class="number">5</span>;<span class="number">3</span> <span class="number">5</span> <span class="number">1</span>]; <span class="comment">%评判矩阵</span></span><br><span class="line"><span class="comment">%% 一致性检验和权向量计算</span></span><br><span class="line">[n,n] = <span class="built_in">size</span>(A);</span><br><span class="line">[v,d] = eig(A);</span><br><span class="line">r = d(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">CI = (r-n)/(n<span class="number">-1</span>);</span><br><span class="line">RI = [<span class="number">0</span> <span class="number">0</span> <span class="number">0.58</span> <span class="number">0.90</span> <span class="number">1.12</span> <span class="number">1.24</span> <span class="number">1.32</span> <span class="number">1.41</span> <span class="number">1.45</span> <span class="number">1.49</span> <span class="number">1.52</span> <span class="number">1.54</span> <span class="number">1.56</span> <span class="number">1.58</span> <span class="number">1.59</span>]</span><br><span class="line">CR = CI/RI(n);</span><br><span class="line"><span class="keyword">if</span> CR&lt;<span class="number">0.10</span></span><br><span class="line">    CR_Result = <span class="string">'通过'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    CR_Result = <span class="string">'不通过'</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 权向量计算</span></span><br><span class="line">w = v(:,<span class="number">1</span>)/sum(v(:,<span class="number">1</span>));</span><br><span class="line">w = w';</span><br><span class="line"><span class="comment">%%输出结果</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'该判断矩阵权向量报告：'</span>);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">'一致性指标：'</span> num2str(CI)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">'一致性比例：'</span> num2str(CR)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">'一致性检验结果：'</span> CR_Result]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">'特征值：'</span> num2str(r)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">'权向量：'</span> num2str(w)]);</span><br></pre></td></tr></table></figure></p>
<h1 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h1><p>优点：层次结构清晰，简化分析流程，灵活多变。</p>
<p>缺点：定性分析多于定量分析，主观意识较强。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>灰色预测</title>
    <url>/2020/04/14/%E7%81%B0%E8%89%B2%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<p> <strong>灰色预测</strong>是通过少量的、不完全的信息，建立数学模型做出预测的一种预测方法。<br><a id="more"></a></p>
<p>灰色预测通过鉴别系统因素之间发展趋势的相异程度，生成有较强规律性的数据序列，然后建立相应的微分方程模型。</p>
<h1 id="灰色预测模型的预测步骤"><a href="#灰色预测模型的预测步骤" class="headerlink" title="灰色预测模型的预测步骤"></a>灰色预测模型的预测步骤</h1><p>对于$GM(1,1)$模型的预测步骤，设有原始序列：</p>
<script type="math/tex; mode=display">{x}^{(0)}=({x}^{(0)}(1),{x}^{(0)}(\text{2}),...,{x}^{(0)}(n)) (n为数据个数)</script><p>如果根据${x}^{(0)}$数据列建立$GM(1,1)$来实现预测功能，则基本的步骤如下：</p>
<ul>
<li><p>步骤1<br>原始数据累加以便弱化随机序列的波动性和随机性，得到新的数据序列：</p>
<script type="math/tex; mode=display">{x}^{(0)}=({x}^{(1)}(1),{x}^{(1)}(2),...,{x}^{(1)}(n))</script><p>其中，$x^{1}(t)$中各数据表示对应前几项数据的累加</p>
<script type="math/tex; mode=display">{x}^{(1)}(t)=\sum\limits_{k=1}^{t}{x}^{(0)}(k), t=1,2,3,...,n</script><p>或</p>
<script type="math/tex; mode=display">{x}^{(1)}(t+1)=\sum\limits_{k=1}^{t+1}{x}^{(0)}(k),t=1,2,3,...,n</script></li>
<li><p>步骤2<br>对$x^{1}(t)$建立$x^{1}(t)$的一阶线性微分方程</p>
<script type="math/tex; mode=display">\frac{d{x}^{(1)}}{dt}+a{x}^{(1)}=\mu</script><p>其中，$a$，$\mu$分别为<code>发展系数</code>和<code>灰色作用量</code>，$a$的有效区间为$(-2,2)$，并记$a$，$\mu$构成的矩阵为</p>
</li>
</ul>
<script type="math/tex; mode=display">
\hat{a}=\left( \begin{matrix} 
a \\
\mu \\
\end{matrix} \right)</script><p>只要求出参数$a$,$\mu$,就能求出${x^{1}}(t)$，进而求出${x}^{(0)}$的未来预测值。</p>
<ul>
<li>步骤3<br>对累加生成数据做均值生成$B$与常数项向量$Y$,即</li>
</ul>
<script type="math/tex; mode=display">
B=\left[ \begin{matrix}
   0.5({x}^{(1)}(1)+{x}^{(1)}(2))  \\
   0.5({x}^{(1)}(2)+{x}^{(1)}(3))  \\
   0.5({x}^{(1)}(n-1)+{x}^{(1)}(n))  \\
\end{matrix} \right]</script><script type="math/tex; mode=display">{Y}_{n}={({x}^{(0)}(2)+{x}^{(0)}(3),...,{x}^{(0)}}(n))^{T}</script><ul>
<li><p>步骤4<br>用最小二乘法求解灰参数$\hat{a}$，则</p>
<script type="math/tex; mode=display">\hat{a}=\left[ \begin{matrix}
 a  \\
 \mu  \\
\end{matrix} \right]=({B}^{T}B)^{-1}{B}^{T}Y</script></li>
<li><p>步骤5<br>将灰参数$\hat{a}$带入到$\frac{d{x}^{(1)}}{dt}+a{x}^{(1)}=\mu$进行求解，得</p>
<script type="math/tex; mode=display">\hat{x}^{(1)}(t+1)=({x}^{(0)}(1)-\frac{\mu }{a}){e}^{-at}+\frac{\mu }{a}</script><p>由于$\hat{a}$是通过最小二乘法求出的近似值，所以$\hat{x}^{(1)}(t+1)$函数表达式是一个近似表达式为了与原序列${x}^{(1)}(t+1)$区分开来故记为$\hat{x}^{(1)}(t+1)$。</p>
</li>
<li><p>步骤6 对函数表达式$\hat{x}^{(1)}(t+1)$及$\hat{x}^{(1)}(t)$进行离散并将二者做差以便还原${x}^{(0)}$原序列，得到近似数据序列$\hat{x}^{(0)}(t+1)$如下：</p>
<script type="math/tex; mode=display">\hat{x}^{(0)}(t+1)=\hat{x}^{(1)}(t+1)-\hat{x}^{(1)}(t)</script></li>
<li><p>步骤7</p>
</li>
</ul>
<p>对建立的灰色模型进行检验，步骤如下：</p>
<ol>
<li>计算${x}^{(0)}$与$\hat{x}^{(0)}(t)$之间的残差${e}^{(0)}(t)$和相对误差$q(x)$：<script type="math/tex; mode=display">{e}^{(0)}(t)={x}^{(0)}-\hat{x}^{(0)}(t)</script><script type="math/tex; mode=display">q(x)={e}^{(0)}(t)/{x}^{(0)}(t)</script></li>
<li>求原始数据${x}^{(0)}$的均值以及方差${s}_{1}$;</li>
<li>求${e}^{(0)}(t)$的平均值$\bar{q}$以及残差的方差${s}_{2}$;</li>
<li>计算方差比$C= \cfrac {s_2} {s_1}$;</li>
<li>求小误差概率$P=P{\left| e(t) \right|&lt;0.6745{s}_{1}}$;</li>
<li>灰色模型精度检验表如表所示：</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">等级</th>
<th style="text-align:center">相对误差$q$</th>
<th style="text-align:center">方差比$C$</th>
<th style="text-align:center">小误差概率$P$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1级</td>
<td style="text-align:center">$&lt;0.01$</td>
<td style="text-align:center">$&lt;0.35$</td>
<td style="text-align:center">$&gt;0.95$</td>
</tr>
<tr>
<td style="text-align:center">2级</td>
<td style="text-align:center">$&lt;0.05$</td>
<td style="text-align:center">$&lt;0.50$</td>
<td style="text-align:center">$&lt;0.80$</td>
</tr>
<tr>
<td style="text-align:center">3级</td>
<td style="text-align:center">$&lt;0.10$</td>
<td style="text-align:center">$&lt;0.65$</td>
<td style="text-align:center">$&lt;0.70$</td>
</tr>
<tr>
<td style="text-align:center">4级</td>
<td style="text-align:center">$&gt;0.20$</td>
<td style="text-align:center">$&gt;0.80$</td>
<td style="text-align:center">$&lt;0.60$</td>
</tr>
</tbody>
</table>
</div>
<p>在实际应用过程中，检验模型精度的方法并不唯一，可以利用上述的方法进行模型的检验，也可以根据$q(x)$的误差百分比并结合预测数据与实际数据之间的测试结果来认定模型是否合理。</p>
<ul>
<li>步骤8</li>
</ul>
<p>利用模型进行预测：</p>
<script type="math/tex; mode=display">\hat{x}^{(0)}=\left[ \underbrace{\hat{x}^{(0)}(1),{\hat{x}^{(0)}}(2),...,\hat{x}^{(0)}(n)}_{原数列的模拟},\underbrace{\hat{x}^{(0)}(n+1),...,\hat{x}^{(0)}(n+m)}_{未来数列的预测} \right]</script><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>用一组数据$[5,11,1,65,27,14,0,3,9,4,2]$实现灰色预测的程序：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">syms a b;</span><br><span class="line">c = [a b]';</span><br><span class="line">A = [<span class="number">5</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">65</span>,<span class="number">27</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>];</span><br><span class="line">B = cumsum(A);     <span class="comment">%原始数据累加</span></span><br><span class="line">n = <span class="built_in">length</span>(A);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : (n<span class="number">-1</span>)</span><br><span class="line">    C(<span class="built_in">i</span>)=(B(<span class="built_in">i</span>)+B(<span class="built_in">i</span>+<span class="number">1</span>))/<span class="number">2</span>;  <span class="comment">%生成累加矩阵</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%计算待定参数的值</span></span><br><span class="line">D = A;D(<span class="number">1</span>) = [];</span><br><span class="line">D = D';</span><br><span class="line">E = [-C;<span class="built_in">ones</span>(<span class="number">1</span>,n<span class="number">-1</span>)];</span><br><span class="line">c = inv(E*E')*E*D;</span><br><span class="line">c = c';</span><br><span class="line">a = c(<span class="number">1</span>); b = c(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%预测后续数据</span></span><br><span class="line">F = []; F(<span class="number">1</span>) = A(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span> : (n+<span class="number">10</span>)</span><br><span class="line">    F(<span class="built_in">i</span>) = (A(<span class="number">1</span>) - b/a)/<span class="built_in">exp</span>(a*(<span class="built_in">i</span><span class="number">-1</span>))+b/a;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">G = []; G(<span class="number">1</span>) = A(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span> : (n+<span class="number">10</span>)</span><br><span class="line">    G(<span class="built_in">i</span>) = F(<span class="built_in">i</span>) - F(<span class="built_in">i</span><span class="number">-1</span>);   <span class="comment">%得到预测出来的数据</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t1 = <span class="number">6</span>:<span class="number">16</span>;</span><br><span class="line">t2 = <span class="number">6</span>:<span class="number">26</span>;</span><br><span class="line">G; a,b     <span class="comment">%输出预测值，发展系数和灰色作用量</span></span><br><span class="line"><span class="built_in">plot</span>(t1,A,<span class="string">'o'</span>,t2,G);  <span class="comment">%原始数据与预测数据的比较</span></span><br></pre></td></tr></table></figure><br>得到的预测图像为：</p>
<p><img src="/2020/04/14/%E7%81%B0%E8%89%B2%E9%A2%84%E6%B5%8B/灰色预测.jpg" alt="灰色预测"></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown编辑数学公式</title>
    <url>/2020/03/16/markdown%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<p> 本篇文章记录一下<strong>如何在markdown中书写数学公式</strong><br><a id="more"></a></p>
<h1 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h1><p>在markdown中插入数学公式的语法是 <code>$数学公式$</code> 和 <code>$$数学公式$$</code></p>
<p><strong>行内公式</strong>是可以让公式在文中与文字或其他东西混编，不独占一行。</p>
<ul>
<li>示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">质能方程$E &#x3D; mc^2$</span><br></pre></td></tr></table></figure></li>
<li>显示</li>
</ul>
<p>质能方程 $E = mc^2$</p>
<p><strong>独立公式</strong>使公式单独占一行，不与文中其他文字等混编</p>
<ul>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$E &#x3D; mc^2$$</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示</p>
<script type="math/tex; mode=display">E = mc^2</script></li>
</ul>
<h1 id="普通公式"><a href="#普通公式" class="headerlink" title="普通公式"></a>普通公式</h1><p>普通的加减乘除数学公式的输入方法与平常的书写一样。</p>
<ul>
<li>示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$x &#x3D; 100 * y + z - 10&#x2F;3$$</span><br></pre></td></tr></table></figure></li>
<li>显示<script type="math/tex; mode=display">x = 100 * y + z - 10/3</script>使用<code>^</code>来表示上标，<code>_</code>来表示下标，如果同时上下标的内容多于一个字符，可以使用<code>{}</code>来将这些内容括起来当作一个整体。<br>与此同时，上下标是可以嵌套的。</li>
<li>示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$x &#x3D; a_&#123;1&#125;^n + a_&#123;2&#125;^n + a_&#123;3&#125;^n$$</span><br></pre></td></tr></table></figure></li>
<li>显示<script type="math/tex; mode=display">x = a_{1}^n + a_{2}^n + a_{3}^n</script></li>
</ul>
<p>如果希望左右两边都能有上下标，可以在字母两边做上下标</p>
<ul>
<li>示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\sideset&#123;^1_2&#125;A&#123;^3_4&#125;$$</span><br></pre></td></tr></table></figure></li>
<li>显示<script type="math/tex; mode=display">{^1_2}A{^3_4}</script></li>
</ul>
<h1 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h1><p><code>()</code>,<code>[]</code>和<code>|</code>都表示他们自己，但是<code>{}</code>因为有特殊的作用因此当需要大括号时一般使用<code>\lbrace \rbrace</code>来表示。</p>
<ul>
<li>示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$f(x, y) &#x3D; 100 * \lbrace[(x + y) * 3] - 5\rbrace$$</span><br></pre></td></tr></table></figure></li>
<li>显示<script type="math/tex; mode=display">f(x, y) = 100 * \lbrace[(x + y) * 3] - 5\rbrace</script></li>
</ul>
<h1 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h1><p>分数使用<code>\frac{分母}{分子}</code>这样的语法，不过推荐使用<code>\cfrac</code>来代替<code>\frac</code>，显示公式不会太挤。</p>
<ul>
<li>示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\frac&#123;1&#125;&#123;3&#125; 与 \cfrac&#123;1&#125;&#123;3&#125;$$</span><br></pre></td></tr></table></figure></li>
<li>显示 <script type="math/tex; mode=display">\frac{1}{3} 与 \cfrac{1}{3}</script></li>
</ul>
<h1 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h1><p>开方使用<code>\sqrt[次数]{被开方数}</code>这样的语法</p>
<ul>
<li>示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\sqrt[3]&#123;X&#125;$$</span><br><span class="line">$$\sqrt&#123;5 - x&#125;$$</span><br></pre></td></tr></table></figure></li>
<li>显示<script type="math/tex; mode=display">\sqrt[3]{X}</script><script type="math/tex; mode=display">\sqrt{5 - x}</script></li>
</ul>
<h1 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:center">符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\pm</code></td>
<td style="text-align:center">$\pm$</td>
</tr>
<tr>
<td style="text-align:center"><code>\times</code></td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center"><code>\div</code></td>
<td style="text-align:center">$\div$</td>
</tr>
<tr>
<td style="text-align:center"><code>\mid</code></td>
<td style="text-align:center">$\mid$</td>
</tr>
<tr>
<td style="text-align:center"><code>\nmid</code></td>
<td style="text-align:center">$\nmid$</td>
</tr>
<tr>
<td style="text-align:center"><code>\cdot</code></td>
<td style="text-align:center">$\cdot$</td>
</tr>
<tr>
<td style="text-align:center"><code>\circ</code></td>
<td style="text-align:center">$\circ$</td>
</tr>
<tr>
<td style="text-align:center"><code>\ast</code></td>
<td style="text-align:center">$\ast$</td>
</tr>
<tr>
<td style="text-align:center"><code>\bigodot</code></td>
<td style="text-align:center">$\bigodot$</td>
</tr>
<tr>
<td style="text-align:center"><code>\bigotimes</code></td>
<td style="text-align:center">$\bigotimes$</td>
</tr>
<tr>
<td style="text-align:center"><code>\bigoplus</code></td>
<td style="text-align:center">$\bigoplus$</td>
</tr>
<tr>
<td style="text-align:center"><code>\leq</code></td>
<td style="text-align:center">$\leq$</td>
</tr>
<tr>
<td style="text-align:center"><code>\geq</code></td>
<td style="text-align:center">$\geq$</td>
</tr>
<tr>
<td style="text-align:center"><code>\neq</code></td>
<td style="text-align:center">$\neq$</td>
</tr>
<tr>
<td style="text-align:center"><code>\approx</code></td>
<td style="text-align:center">$\approx$</td>
</tr>
<tr>
<td style="text-align:center"><code>\equiv</code></td>
<td style="text-align:center">$\equiv$</td>
</tr>
<tr>
<td style="text-align:center"><code>\sum</code></td>
<td style="text-align:center">$\sum$</td>
</tr>
<tr>
<td style="text-align:center"><code>\prod</code></td>
<td style="text-align:center">$\prod$</td>
</tr>
<tr>
<td style="text-align:center"><code>\coprod</code></td>
<td style="text-align:center">$\coprod$</td>
</tr>
</tbody>
</table>
</div>
<h1 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h1><p>如表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:center">大写</th>
<th style="text-align:center">代码</th>
<th style="text-align:center">小写</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>A</code></td>
<td style="text-align:center">$A$</td>
<td style="text-align:center"><code>\alpha</code></td>
<td style="text-align:center">$\alpha$</td>
</tr>
<tr>
<td style="text-align:center"><code>B</code></td>
<td style="text-align:center">$B$</td>
<td style="text-align:center"><code>\beta</code></td>
<td style="text-align:center">$\beta$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Gamma</code></td>
<td style="text-align:center">$\Gamma$</td>
<td style="text-align:center"><code>gamma</code></td>
<td style="text-align:center">$\gamma$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Delta</code></td>
<td style="text-align:center">$\Delta$</td>
<td style="text-align:center"><code>\delta</code></td>
<td style="text-align:center">$\delta$</td>
</tr>
<tr>
<td style="text-align:center"><code>E</code></td>
<td style="text-align:center">$E$</td>
<td style="text-align:center"><code>\epsilon</code></td>
<td style="text-align:center">$\epsilon$</td>
</tr>
<tr>
<td style="text-align:center"><code>Z</code></td>
<td style="text-align:center">$Z$</td>
<td style="text-align:center"><code>\zeta</code></td>
<td style="text-align:center">$\zeta$</td>
</tr>
<tr>
<td style="text-align:center"><code>H</code></td>
<td style="text-align:center">$H$</td>
<td style="text-align:center"><code>\eta</code></td>
<td style="text-align:center">$\eta$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Theta</code></td>
<td style="text-align:center">$\Theta$</td>
<td style="text-align:center"><code>\theta</code></td>
<td style="text-align:center">$\theta$</td>
</tr>
<tr>
<td style="text-align:center"><code>I</code></td>
<td style="text-align:center">$I$</td>
<td style="text-align:center"><code>\iota</code></td>
<td style="text-align:center">$\iota$</td>
</tr>
<tr>
<td style="text-align:center"><code>K</code></td>
<td style="text-align:center">$K$</td>
<td style="text-align:center"><code>\kappa</code></td>
<td style="text-align:center">$\kappa$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Lambda</code></td>
<td style="text-align:center">$\Lambda$</td>
<td style="text-align:center"><code>\lambda</code></td>
<td style="text-align:center">$\lambda$</td>
</tr>
<tr>
<td style="text-align:center"><code>M</code></td>
<td style="text-align:center">$M$</td>
<td style="text-align:center"><code>\mu</code></td>
<td style="text-align:center">$\mu$</td>
</tr>
<tr>
<td style="text-align:center"><code>N</code></td>
<td style="text-align:center">$N$</td>
<td style="text-align:center"><code>\nu</code></td>
<td style="text-align:center">$\nu$</td>
</tr>
<tr>
<td style="text-align:center"><code>\xi</code></td>
<td style="text-align:center">$\xi$</td>
<td style="text-align:center"><code>\xi</code></td>
<td style="text-align:center">$\xi$</td>
</tr>
<tr>
<td style="text-align:center"><code>O</code></td>
<td style="text-align:center">$O$</td>
<td style="text-align:center"><code>\omicron</code></td>
<td style="text-align:center">$\omicron$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Pi</code></td>
<td style="text-align:center">$\Pi$</td>
<td style="text-align:center"><code>\pi</code></td>
<td style="text-align:center">$\pi$</td>
</tr>
<tr>
<td style="text-align:center"><code>P</code></td>
<td style="text-align:center">$P$</td>
<td style="text-align:center"><code>\rho</code></td>
<td style="text-align:center">$\rho$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Sigma</code></td>
<td style="text-align:center">$\Sigma$</td>
<td style="text-align:center"><code>\sigma</code></td>
<td style="text-align:center">$\sigma$</td>
</tr>
<tr>
<td style="text-align:center"><code>T</code></td>
<td style="text-align:center">$T$</td>
<td style="text-align:center"><code>\tau</code></td>
<td style="text-align:center">$\tau$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Upsilon</code></td>
<td style="text-align:center">$\Upsilon$</td>
<td style="text-align:center"><code>\upsilon</code></td>
<td style="text-align:center">$\upsilon$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Phi</code></td>
<td style="text-align:center">$\Phi$</td>
<td style="text-align:center"><code>\phi</code></td>
<td style="text-align:center">$\phi$</td>
</tr>
<tr>
<td style="text-align:center"><code>X</code></td>
<td style="text-align:center">$X$</td>
<td style="text-align:center"><code>\chi</code></td>
<td style="text-align:center">$\chi$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Psi</code></td>
<td style="text-align:center">$\Psi$</td>
<td style="text-align:center"><code>\psi</code></td>
<td style="text-align:center">$\psi$</td>
</tr>
<tr>
<td style="text-align:center"><code>\Omega</code></td>
<td style="text-align:center">$\Omega$</td>
<td style="text-align:center"><code>\omega</code></td>
<td style="text-align:center">$\omega$</td>
</tr>
</tbody>
</table>
</div>
<h1 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:center">符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\emptyset</code></td>
<td style="text-align:center">$\emptyset$</td>
</tr>
<tr>
<td style="text-align:center"><code>\in</code></td>
<td style="text-align:center">$\in$</td>
</tr>
<tr>
<td style="text-align:center"><code>\notin</code></td>
<td style="text-align:center">$\notin$</td>
</tr>
<tr>
<td style="text-align:center"><code>\subset</code></td>
<td style="text-align:center">$\subset$</td>
</tr>
<tr>
<td style="text-align:center"><code>\supset</code></td>
<td style="text-align:center">$\supset$</td>
</tr>
<tr>
<td style="text-align:center"><code>\supseteq</code></td>
<td style="text-align:center">$\supseteq$</td>
</tr>
<tr>
<td style="text-align:center"><code>\bigcap</code></td>
<td style="text-align:center">$\bigcap$</td>
</tr>
<tr>
<td style="text-align:center"><code>\bigcup</code></td>
<td style="text-align:center">$\bigcup$</td>
</tr>
<tr>
<td style="text-align:center"><code>\bigvee</code></td>
<td style="text-align:center">$\bigvee$</td>
</tr>
<tr>
<td style="text-align:center"><code>\bigwedge</code></td>
<td style="text-align:center">$\bigwedge$</td>
</tr>
<tr>
<td style="text-align:center"><code>\biguplus</code></td>
<td style="text-align:center">$\biguplus$</td>
</tr>
<tr>
<td style="text-align:center"><code>\bigsqcup</code></td>
<td style="text-align:center">$\bigsqcup$</td>
</tr>
</tbody>
</table>
</div>
<h1 id="对数运算符"><a href="#对数运算符" class="headerlink" title="对数运算符"></a>对数运算符</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:center">符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\log</code></td>
<td style="text-align:center">$\log$</td>
</tr>
<tr>
<td style="text-align:center"><code>\lg</code></td>
<td style="text-align:center">$\lg$</td>
</tr>
<tr>
<td style="text-align:center"><code>\ln</code></td>
<td style="text-align:center">$\ln$</td>
</tr>
</tbody>
</table>
</div>
<h1 id="三角运算符"><a href="#三角运算符" class="headerlink" title="三角运算符"></a>三角运算符</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:center">符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\bot</code></td>
<td style="text-align:center">$\bot$</td>
</tr>
<tr>
<td style="text-align:center"><code>\angle</code></td>
<td style="text-align:center">$\angle$</td>
</tr>
<tr>
<td style="text-align:center"><code>\sin</code></td>
<td style="text-align:center">$\sin$</td>
</tr>
<tr>
<td style="text-align:center"><code>\cos</code></td>
<td style="text-align:center">$\cos$</td>
</tr>
<tr>
<td style="text-align:center"><code>\tan</code></td>
<td style="text-align:center">$\tan$</td>
</tr>
<tr>
<td style="text-align:center"><code>\cot</code></td>
<td style="text-align:center">$\cot$</td>
</tr>
<tr>
<td style="text-align:center"><code>\sec</code></td>
<td style="text-align:center">$\sec$</td>
</tr>
<tr>
<td style="text-align:center"><code>\csc</code></td>
<td style="text-align:center">$\csc$</td>
</tr>
</tbody>
</table>
</div>
<h1 id="微积分运算符"><a href="#微积分运算符" class="headerlink" title="微积分运算符"></a>微积分运算符</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:center">符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\prime</code></td>
<td style="text-align:center">$\prime$</td>
</tr>
<tr>
<td style="text-align:center"><code>\int</code></td>
<td style="text-align:center">$\int$</td>
</tr>
<tr>
<td style="text-align:center"><code>\iint</code></td>
<td style="text-align:center">$\iint$</td>
</tr>
<tr>
<td style="text-align:center"><code>\iiint</code></td>
<td style="text-align:center">$\iiint$</td>
</tr>
<tr>
<td style="text-align:center"><code>\oint</code></td>
<td style="text-align:center">$\oint$</td>
</tr>
<tr>
<td style="text-align:center"><code>\lim</code></td>
<td style="text-align:center">$\lim$</td>
</tr>
<tr>
<td style="text-align:center"><code>\infty</code></td>
<td style="text-align:center">$\infty$</td>
</tr>
<tr>
<td style="text-align:center"><code>\nabla</code></td>
<td style="text-align:center">$\nabla$</td>
</tr>
<tr>
<td style="text-align:center"><code>\mathrm{d}</code></td>
<td style="text-align:center">$\mathrm{d}$</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown的使用</title>
    <url>/2020/02/02/markdown%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>以后的博客都是按照markdown语法规则，这里备份下markdown的基本语法<br><a id="more"></a></p>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>  设置n级标题只需在标题前加上n个<code>#</code>即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure></p>
<h1 id="如何插入图片"><a href="#如何插入图片" class="headerlink" title="如何插入图片"></a>如何插入图片</h1><p>首先我们要将站点配置文件<code>_config.yml</code>中的<code>post_asset_folder</code>选项设为 <code>true</code><br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><br>打开后hexo在你每次<code>hexo new [title]</code>时自动创建同名字的文件夹</p>
<p>我们可以用标签插件来引用图片<br><code>![替代文字]（图片名.jpg）</code></p>
<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p>  用两个<code>*</code>包含的一段文本就是粗体，用一个<code>*</code>包含的一段文本就是斜体，用两个<code>~</code>包含的一段文本就是删除线。<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*倾斜的字体*</span><br><span class="line">**粗体文字**</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><br>  效果如下：<br>  <em>倾斜的字体</em><br>  <strong>粗体文字</strong><br>  <del>删除线</del></p>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>使用<code>|</code>来表示表格的框，用<code>:</code>来进行对齐方式，<code>-</code>最少两个。<br><code>:---</code>代表左对齐<br><code>:--:</code>代表居中对齐<br><code>---:</code>代表右对齐<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|A|A|A|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|A|A|A|</span><br><span class="line">|B|B|B|</span><br></pre></td></tr></table></figure><br>效果如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:center">A</th>
<th style="text-align:right">A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:center">A</td>
<td style="text-align:right">A</td>
</tr>
<tr>
<td style="text-align:left">B</td>
<td style="text-align:center">B</td>
<td style="text-align:right">B</td>
</tr>
</tbody>
</table>
</div>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>  如果需要加入列表格式，只需要在文字前面加上<code>-</code>就可以了，例如：<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 文本1</span><br><span class="line">- 文本2</span><br><span class="line">- 文本3</span><br></pre></td></tr></table></figure><br>  如果需要有序列表，也可以在文字前面加上<code>1.</code> <code>2.</code> <code>3.</code>即可，例如：<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 文本1</span><br><span class="line">2. 文本2</span><br><span class="line">3. 文本3</span><br></pre></td></tr></table></figure><br>  要注意<code>-</code> <code>1.</code>和文本之间要保留一个字符的空格。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>  如果想在自己的文章中加一段引用的话，就需要在引用文字前加上<code>&gt;</code>就好了,<code>&gt;</code>和文本之间也要有一个字符的空格。例如：</p>
<blockquote>
<p>始于颜值，陷于才华，忠于人品。</p>
</blockquote>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的使用</title>
    <url>/2020/01/13/hexo%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>hexo 主题启用以及相关设置</p>
<blockquote>
<p>备份个人设置，有些方案手集于互联网</p>
</blockquote>
<a id="more"></a>
<h1 id="如何打开博客"><a href="#如何打开博客" class="headerlink" title="如何打开博客"></a>如何打开博客</h1><p>  我们写的博客一般都在<code>blog/source/_posts</code> 文件夹下，打开cmd，在管理员权限下输入：<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd blog&#x2F;source&#x2F;_posts&#x2F;具体写内容的文档名字</span><br></pre></td></tr></table></figure></p>
<h1 id="主题下载并启用"><a href="#主题下载并启用" class="headerlink" title="主题下载并启用"></a>主题下载并启用</h1><p>进入命令行，下载next主题，输入:<br><code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code><br>修改站点配置文件<code>_config.yml</code>,找到如下代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: landscape</span><br></pre></td></tr></table></figure><br>将<code>landscape</code>修改为 <code>next</code>即可。</p>
<h1 id="修改语言"><a href="#修改语言" class="headerlink" title="修改语言"></a>修改语言</h1><p>打开站点配置文件，搜索<code>language</code>,找到如下代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">author:</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure><br>在<code>language</code>后面输入<code>zh-CN</code>。<br>注意：冒号后面必须有一个空格。</p>
<h1 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h1><p>next主题自带四种样式。<br>在主题配置文件<code>/next/_config.yml</code>中查找：<code>scheme</code>，找到如下代码：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure><br>选择喜欢的一种样式，去掉前面的<code>#</code>,其他主题前面加上<code>#</code>即可。</p>
<h1 id="设置个人头像"><a href="#设置个人头像" class="headerlink" title="设置个人头像"></a>设置个人头像</h1><p>打开<code>主题配置文件</code>，找到<code>sidebar Avatar</code>字段：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # in theme directory(source/images): /images/avatar.gif</span><br><span class="line">  # in site  directory(source/uploads): /uploads/avatar.gif</span><br><span class="line">  # You can also use other linking images.</span><br><span class="line">  url: #/images/avatar.jpg</span><br><span class="line">  # If true, the avatar would be dispalyed in circle.</span><br><span class="line">  rounded: false</span><br><span class="line">  # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.</span><br><span class="line">  opacity: 1</span><br><span class="line">  # If true, the avatar would be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure><br>将<code>url</code>后面的<code>#</code>删掉，然后把你的头像命名为<code>avatar.jpg</code>放入<code>themes/next/source/images</code>中<br>配置项说明：</p>
<ul>
<li><code>rounded</code> : 设置头像为圆形</li>
<li><code>opacity</code> : 设置头像的不透明度</li>
<li><code>rotated</code> : 设置头像可旋转</li>
</ul>
<h1 id="添加页面"><a href="#添加页面" class="headerlink" title="添加页面"></a>添加页面</h1><h2 id="添加标签页面"><a href="#添加标签页面" class="headerlink" title="添加标签页面"></a>添加标签页面</h2><p>使用 <code>hexo new page tags</code>新建一个 标签 页面。<br>主题的<code>_config.yml</code>文件中的<code>menu</code>中进行匹配<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: /     <span class="comment">//主页</span></span><br><span class="line">categories: /categories  <span class="comment">//分类</span></span><br><span class="line">archives: /archives      <span class="comment">//归档</span></span><br><span class="line">tages: /tages            <span class="comment">//标签   （添加此行即可）</span></span><br><span class="line">about: /about            <span class="comment">//关于</span></span><br></pre></td></tr></table></figure></p>
<p>  在文章中添加标签:<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">title：使用标签</span><br><span class="line">tags:</span><br><span class="line">  -Testing    (这篇文章的标签)</span><br><span class="line">  -<span class="function">Another <span class="title">Tag</span><span class="params">(这篇文章的标签)</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="添加分类页面"><a href="#添加分类页面" class="headerlink" title="添加分类页面"></a>添加分类页面</h2><p>使用 <code>hexo new page categories</code>新建一个 分类 页面。<br>主题的<code>_config,yml</code>文件夹中的<code>menu</code>中进行匹配<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: /     <span class="comment">//主页</span></span><br><span class="line">categories: /categories  <span class="comment">//分类    （添加此行即可）</span></span><br><span class="line">archives: /archives      <span class="comment">//归档</span></span><br><span class="line">tages: /tages            <span class="comment">//标签   </span></span><br><span class="line">about: /about            <span class="comment">//关于</span></span><br></pre></td></tr></table></figure><br>在文章中添加分类:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">title:添加分类</span><br><span class="line">categories:</span><br><span class="line">-hexo    (这就是文章的分类)</span><br></pre></td></tr></table></figure></p>
<h1 id="修改小型代码块颜色"><a href="#修改小型代码块颜色" class="headerlink" title="修改小型代码块颜色"></a>修改小型代码块颜色</h1><p>修改<code>\themes\next\source\css\ _variables\base.styl</code>文件，加入自定义颜色：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$black-deep   = #222</span><br><span class="line">$red          = #ff2a2a</span><br><span class="line">$blue-bright  = #87daff</span><br><span class="line">$blue         = #0684bd</span><br><span class="line">$blue-deep    = #262a30</span><br><span class="line">$orange       = #fc6423</span><br><span class="line"><span class="comment">// 下面是我自定义的颜色</span></span><br><span class="line">$my-code-foreground = #dd0055  // 用``围出的代码块字体颜色</span><br><span class="line">$my-code-background = #eee  // 用``围出的代码块背景颜色</span><br></pre></td></tr></table></figure><br>修改<code>$code-background</code>和<code>$code-foreground</code>的值：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Code &amp; Code Blocks &#x2F;&#x2F; 用&#96;&#96;围出的代码块 &#x2F;&#x2F; -------------------------------------</span><br><span class="line">$code-font-family               &#x3D; $font-family-monospace </span><br><span class="line">$code-font-size                 &#x3D; 15px </span><br><span class="line">$code-background                &#x3D; $my-code-background </span><br><span class="line">$code-foreground                &#x3D; $my-code-foreground </span><br><span class="line">$code-border-radius             &#x3D; 4px</span><br></pre></td></tr></table></figure></p>
<h1 id="添加背景图片"><a href="#添加背景图片" class="headerlink" title="添加背景图片"></a>添加背景图片</h1><p>在网站上找到的方法都要有<code>custom.styl</code>这个文件，但next主题7.5版本后就没有这个文件了，于是在主题<code>_config.yml</code>发现<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.swig</span><br><span class="line">  #header: source/_data/header.swig</span><br><span class="line">  #sidebar: source/_data/sidebar.swig</span><br><span class="line">  #postMeta: source/_data/post-meta.swig</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.swig</span><br><span class="line">  #footer: source/_data/footer.swig</span><br><span class="line">  #bodyEnd: source/_data/body-end.swig</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  #style: source/_data/styles.styl</span><br></pre></td></tr></table></figure><br>将主题中的<code>_config.yml</code>中对应的#去掉<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style: source&#x2F;_data&#x2F;styles.styl</span><br></pre></td></tr></table></figure><br>在根目录<code>source</code>下新建<code>_data/styles.styl</code>在文本中加入以下代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line"> 	background:url(<span class="regexp">/images/</span>background.jpg);</span><br><span class="line"> 	background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:<span class="number">50</span>% <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>暂时只做一下记录，等有好的背景图片的时候再试试是否可行。</p>
<h1 id="代码主题"><a href="#代码主题" class="headerlink" title="代码主题"></a>代码主题</h1><p><code>nexr</code>使用<code>Tomorrow Theme</code>作为代码高亮主题，有很多款式可以选择。<br>更改<code>主题配置文件</code>中的<code>highlight_theme</code>字段，将其设置喜欢的<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Code Highlight theme</span><br><span class="line"># Available value: normal | night | night eighties | night blue | night bright</span><br><span class="line"># https://github.com/chriskempson/tomorrow-theme</span><br><span class="line">highlight_theme: normal</span><br></pre></td></tr></table></figure></p>
<h1 id="给文章添加阴影"><a href="#给文章添加阴影" class="headerlink" title="给文章添加阴影"></a>给文章添加阴影</h1><p>在<code>next</code>主题下找到<code>\next\source\css_common\components\post</code>下的<code>post.styl</code>文件找到<code>.post-block</code><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.use-motion &#123;</span><br><span class="line">  <span class="keyword">if</span> (hexo-config(<span class="string">'motion.transition.post_block'</span>)) &#123;</span><br><span class="line">    .post-block  &#123;  <span class="comment">//此处为添加文章阴影</span></span><br><span class="line">   opacity: <span class="number">0</span>;</span><br><span class="line">   margin-top: <span class="number">60</span>px;</span><br><span class="line">   margin-bottom: <span class="number">60</span>px;</span><br><span class="line">   padding: <span class="number">25</span>px;</span><br><span class="line">   -webkit-box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, <span class="number">.5</span>);</span><br><span class="line">   -moz-box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">.5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">       .pagination, .comments &#123;</span><br><span class="line">      opacity: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
